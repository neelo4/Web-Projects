import { type BrandDataProps, connectIagBrand } from '@iag-common/iag-brand-context';
import { Icon, Link } from '@iag/chroma-react-ui.components';
import type React from 'react';
import { useContext, useEffect, useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { PaymentIntent } from 'ssc-packages/packages/mfe';
import { FeatureName, useFeaturesConfig } from '../../../features-config';
import { formatDate } from '../../../shared/utils/dateUtils';
import { getChromaBrand } from '../../brand-utils/getBrandConfig';
import usePreparePaymentData from '../../hooks/api/usePreparePaymentData';
import useEventListener from '../../hooks/useEventListener';
import { mapProductType } from '../../mappers/mapProductType';
import {
  ErrorCode,
  EventType,
  type HostErrorEvent,
  type HostEvent,
  type HostSuccessEvent,
} from '../../models/EventTypes';
import type { PayNowReceiptData } from '../../models/PayNowReceipt';
import { type PaymentMFEError, PaymentMFEType } from '../../models/PaymentType';
import { ElementType, Interaction } from '../../models/SiteTracking';
import { getBrand } from '../../models/brands';
import { SiteTrackingContext } from '../../sitetracking/SiteTrackingProvider';
import { getTechErrorTraceId } from '../../utils/policyUtils';
import StandardLoader from '../shared/StandardLoader';
import TechnicalError from '../shared/TechnicalError';
import { OneOffPaymentMfe, type OneOffPaymentMfeProps } from './OneOffPaymentMfe';
import { type OneOffPaymentProps, PaymentMfe } from './PaymentMfe';

type PreparePaymentProps = {
  postCode: string;
  policyNumber: string;
  transactionNumber: string;
  versionNumber?: string;
  isRenewal?: boolean;
};

const PreparePayment: React.FC<BrandDataProps & PreparePaymentProps> = ({
  t,
  tt,
  postCode,
  policyNumber,
  transactionNumber,
  versionNumber,
  isRenewal,
}) => {
  const navigate = useNavigate();
  const [paymentData, setPaymentData] = useState<OneOffPaymentMfeProps | OneOffPaymentProps>();
  const [paymentError, setPaymentError] = useState<PaymentMFEError>();
  const trackingEventContext = useContext(SiteTrackingContext);
  const { [FeatureName.USE_UNIFIED_PAYMENT_MFE]: useUnifiedPaymentMfe } = useFeaturesConfig();

  const country = tt('constants.brandCountryCode');
  const brand = getBrand();
  const chromaBrand = getChromaBrand(brand);

  const handleBackButtonClick: React.MouseEventHandler<HTMLAnchorElement> = (event) => {
    event.preventDefault();
    navigate(getHistoryPositionDelta());
  };

  const getHistoryPositionDelta = () => (location.pathname.endsWith('/payment') ? -1 : -2);

  const { data, success, preparePaymentData, error, processing } = usePreparePaymentData({
    policyNumber,
    postCode,
    paymentIntent: useUnifiedPaymentMfe ? PaymentIntent.PAYMENT_ONEOFF : PaymentIntent.PAYMENT,
    isRenewal,
  });
  // biome-ignore lint: existing behavior
  useEffect(() => {
    if (error) {
      setPaymentError({ type: PaymentMFEType.OneOff });
    }

    if (success && data) {
      // SSJ-12706: Legacy one off payments use PaymentIntent.PAYMENT
      // and associated logic below can be removed once all brands
      // are migrated to Unified Payment MFE
      switch (data.paymentIntent) {
        case PaymentIntent.PAYMENT:
          setPaymentData({
            ...data,
            paymentAmount: data.amount,
            partyId: data.customerId,
            country: country,
            ancestors: ['online-account'],
            options: { chromaBrand, ...(isRenewal && { transactionType: 'renewal' }) },
          });
          break;
        case PaymentIntent.PAYMENT_ONEOFF:
          setPaymentData({
            ...data,
            ancestors: ['online-account'],
            options: { chromaBrand },
            paymentAmount: data.amount,
          });
          break;
      }
    }
  }, [data, success, error, processing]);

  const handlePaymentInformationEvent = (eventObject: HostSuccessEvent) => {
    switch (eventObject.paymentEventType) {
      case 'PAYMENT_SUCCESS':
      case 'PAYMENT_PARTIAL_SUCCESS':
        handleSuccessEvent(eventObject);
        break;
      case 'PAYMENT_DISCONTINUED':
        handlePaymentDiscontinued();
        break;
      default:
        console.log('[PVMF] MFE CLP Payment Status Response', 'unknown event');
        break;
    }
  };

  const handleSuccessEvent = (eventObject: HostSuccessEvent) => {
    const { cardInfo } = eventObject.paymentAccountDetails;

    const receiptData: PayNowReceiptData = {
      bcReceipt: eventObject.receipts?.length
        ? eventObject.receipts[0].receipt_number
        : (eventObject.bcReceipt ?? undefined),
      paymentMethod: eventObject.paymentAccountDetails.paymentMethod,
      amount: eventObject.paymentAccountDetails.paymentAmount,
      ...(cardInfo && {
        cardInfo: {
          cardBrand: cardInfo.cardBrand,
          lastFour: cardInfo.lastFour,
          maskedCardNumber: cardInfo.maskedCardNumber?.substring(6),
          holderName: cardInfo.holderName,
        },
      }),
      paymentDate: formatDate(new Date(), 'E, dd MMM yyyy'),
      productType: mapProductType(paymentData.product),
      transactionNumber: transactionNumber,
      paymentInstrumentId: eventObject.paymentInstrumentId ?? undefined,
      isRenewalPolicy: isRenewal,
      receiptNumber: eventObject.receiptNumber,
      versionNumber: versionNumber,
      hmacSignature: data.hmacSignature,
    };
    trackingEventContext.dispatch({
      element: {
        type: ElementType.ALERT,
        subType: 'success',
        name:
          eventObject.paymentEventType === 'PAYMENT_SUCCESS'
            ? 'payment-success'
            : 'payment-partial-success',
      },
      interaction: Interaction.SHOW,
    });
    navigate('/policies/payNowReceipt', {
      state: { policyNumber, data: receiptData },
      replace: true,
    });
  };

  const handlePaymentDiscontinued = () => navigate(getHistoryPositionDelta());

  const handleErrorEvent = (errorEvent: HostErrorEvent) => {
    if (errorEvent.errorCode === ErrorCode.CLP_EXCEED_MAX_ATTEMPTS) {
      setPaymentError({ code: ErrorCode.CLP_EXCEED_MAX_ATTEMPTS, type: PaymentMFEType.OneOff });
    } else {
      setPaymentError({ code: ErrorCode.TECHNICAL_ERROR, type: PaymentMFEType.OneOff });
    }
  };

  const paymentEventListener = (event: Event) => {
    const { eventType, eventObject } = (event as CustomEvent<HostEvent>).detail;

    switch (eventType) {
      case 'PAYMENT_INFORMATION':
        handlePaymentInformationEvent(eventObject as HostSuccessEvent);
        break;
      case 'ERROR_EVENT':
        handleErrorEvent(eventObject as HostErrorEvent);
        break;
    }
  };

  useEventListener(
    useUnifiedPaymentMfe ? EventType.PaymentEvent : EventType.OneOffPaymentEvent,
    paymentEventListener
  );

  if (!data && !processing && !error) {
    preparePaymentData();
  }

  return paymentError ? (
    <>
      <Link onClick={handleBackButtonClick}>
        <Icon className="i-angle-left pv-text-xl" />
        {tt('labels.back')}
      </Link>
      {paymentError.code ? (
        <TechnicalError
          id="PreparePaymentError"
          title={tt(`error.paymentMFEError.${paymentError.type}.${paymentError.code}.title`)}
          message={t(`error.paymentMFEError.${paymentError.type}.${paymentError.code}.message`)}
        />
      ) : (
        <TechnicalError id="PreparePaymentError" traceId={getTechErrorTraceId()} />
      )}
    </>
  ) : paymentData ? (
    useUnifiedPaymentMfe ? (
      <PaymentMfe {...(paymentData as OneOffPaymentProps)} />
    ) : (
      <OneOffPaymentMfe {...(paymentData as OneOffPaymentMfeProps)} />
    )
  ) : (
    <StandardLoader />
  );
};

export default connectIagBrand()(PreparePayment);
