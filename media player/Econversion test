import { fireEvent, render, screen } from '@testing-library/react';
import EDocsConversionView from './EDocsConversionView';

import { waitFor } from '@testing-library/react';
import { I18nextProvider } from 'react-i18next';
import { useSaveEDocs } from '../../hooks/useSaveEDocs';
import { BrandEnum } from '../../models/brands';
import * as eDocsUtils from '../../utils/eDocsUtils';
import { getI18next } from '../../utils/test-utils/i18nForTests';
import { AppContextProvider } from '../../AppContext';
import { BrowserRouter as Router } from 'react-router-dom';

jest.mock('../../hooks/useSaveEDocs');

const mockUseSaveEDocs = useSaveEDocs as jest.MockedFunction<typeof useSaveEDocs>;
mockUseSaveEDocs.mockReturnValue({
  updateEDocsCorrespondence: jest.fn().mockImplementation(() => Promise.resolve()),
  isLoading: false,
  response: { status: true },
  error: null,
});

const testPrimaryEmail = 'abc@gmail.com';
const eDocsConversionPropArg = {
  partyId: 'IAG001',
  primaryEmail: testPrimaryEmail,
  brand: BrandEnum.NRMA,
  modalCloseHandler: jest.fn(),
};
const setup = async (): Promise<void> => {
  render(
    <I18nextProvider i18n={await getI18next(eDocsConversionPropArg.brand)}>
      <Router>
        <AppContextProvider partyId={eDocsConversionPropArg.partyId}>
          <EDocsConversionView {...eDocsConversionPropArg} />
        </AppContextProvider>
      </Router>
    </I18nextProvider>,
  );
};

describe('EDocsConversionView', () => {
  beforeEach(async () => {
    await setup();
  });
  test('renders EDocsConversionView input, consent, button and texts', () => {
    const inputElement = screen.getByRole('textbox', {});
    expect(inputElement).toHaveValue(testPrimaryEmail);

    const consentElement = screen.getByRole('checkbox', { name: 'edocsConsent' });
    expect(consentElement).toBeInTheDocument();

    const buttonElement = screen.getByTestId('save');
    expect(buttonElement).toBeInTheDocument();

    const policiesSwitchButtonElement = screen.getByTestId('policies-to-switch-button');
    expect(policiesSwitchButtonElement).toBeInTheDocument();
  });

  test('consent is checked,button clicked and saveEDocs is called', () => {
    fireEvent.click(screen.getByRole('checkbox', { name: 'edocsConsent' }));
    const buttonElement = screen.getByTestId('save');
    buttonElement.click();

    const { updateEDocsCorrespondence } = useSaveEDocs(eDocsConversionPropArg);
    // Check if saveEDocs was called
    expect(updateEDocsCorrespondence).toHaveBeenCalledTimes(1);
  });

  test('consent is checked, button clicked, saveDocs and trigger window event', async () => {
    const triggerSaveEDocsEventSpy = jest.spyOn(eDocsUtils, 'triggerSaveEDocsEvent');
    fireEvent.click(screen.getByRole('checkbox', { name: 'edocsConsent' }));
    const buttonElement = screen.getByTestId('save');
    buttonElement.click();

    await waitFor(() => {
      expect(triggerSaveEDocsEventSpy).toHaveBeenCalled();
    });
    triggerSaveEDocsEventSpy.mockRestore();
  });

  test('saveEDocs is not fired without eDoc consent', () => {
    fireEvent.click(screen.getByTestId('save'));
    const { updateEDocsCorrespondence } = useSaveEDocs(eDocsConversionPropArg);
    expect(updateEDocsCorrespondence).not.toHaveBeenCalled();
  });

  test('displays an error message when eDoc consent is not given', () => {
    fireEvent.click(screen.getByTestId('save'));
    expect(screen.getByText('Select checkbox')).toBeInTheDocument();
    const { updateEDocsCorrespondence } = useSaveEDocs(eDocsConversionPropArg);
    expect(updateEDocsCorrespondence).not.toHaveBeenCalled();
  });
});
