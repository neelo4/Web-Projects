import { gql } from '@apollo/client';
import { MockedProvider } from '@apollo/client/testing';
import { renderHook, act } from '@testing-library/react-hooks';
import React from 'react';
import { AppContext } from '../../AppContext';
import { ONBOARDING_KEY } from '../../components/shared/Constants';
import { useFeaturesConfig } from '../../features-config';
import { getActivePolicyStatus } from '../../models/PolicyStatus';
import { ElementType, Interaction } from '../../models/SiteTracking';
import { SiteTrackingContext } from '../../sitetracking/SiteTrackingProvider';
import useBrowserDetect from '../useBrowserDetect';
import { useGetOnboardingAndEdocsDetails } from './useGetOnboardingAndEdocsDetails';

jest.mock('./useApi', () => ({
  useApiQuery: jest.fn(() => [jest.fn(), {}]),
}));

jest.mock('../../features-config', () => ({
  useFeaturesConfig: jest.fn().mockReturnValue(false),
  FeatureName: {
    SHOW_DOOTB_ONBOARDING: 'SHOW_DOOTB_ONBOARDING',
    SHOW_DOOTB_EDOCS_MODAL: 'SHOW_DOOTB_EDOCS_MODAL',
  },
}));

const mockAppState = {
  appState: {
    externalReturnURL: 'return-url',
    prefillId: 'prefill-id',
  },
  setAppState: jest.fn(),
};

// Mock dependencies
jest.mock('../../features-config');
jest.mock('../useBrowserDetect');
jest.mock('../../models/PolicyStatus');

const ONBOARDING_QUERY = gql`
  query getOnboardingAndEdocsStatus($policy_statuses: [String]) {
    getOnboardingAndEdocsStatus(policyStatuses: $policy_statuses)
  }
`;

describe('useGetOnboardingAndEdocsDetails', () => {
  const mockDispatch = jest.fn();
  const mockSetAppState = jest.fn();

  const mockAppContextValue = {
    setAppState: mockSetAppState,
    appState: {},
  };

  // Define wrapper type
  type WrapperProps = {
    children: React.ReactNode;
    mocks?: any[];
  };

  // Create reusable wrapper component
  const createWrapperWithTracking = (mocks: any[] = []) => {
    const Wrapper: React.FC<WrapperProps> = ({ children }) => (
      <AppContext.Provider value={mockAppContextValue}>
        <SiteTrackingContext.Provider value={{ dispatch: mockDispatch }}>
          <MockedProvider mocks={mocks} addTypename={false}>
            {children}
          </MockedProvider>
        </SiteTrackingContext.Provider>
      </AppContext.Provider>
    );
    return Wrapper;
  };

  beforeEach(() => {
    jest.clearAllMocks();
    (useFeaturesConfig as jest.Mock).mockImplementation(() => true);
    (useBrowserDetect as jest.Mock).mockImplementation(() => ({ isMobileApp: false }));
    (getActivePolicyStatus as jest.Mock).mockReturnValue(['ACTIVE']);
    window.sessionStorage.clear();
  });

  describe('Tracking Events', () => {
    it('should skip query when using mobile app', async () => {
      (useBrowserDetect as jest.Mock).mockReturnValue({ isMobileApp: true });
      
      let rendered;
      await act(async () => {
        rendered = renderHook(
          () => useGetOnboardingAndEdocsDetails(mockAppState.setAppState),
          { wrapper: createWrapperWithTracking() }
        );
        await new Promise(resolve => setTimeout(resolve, 0));
      });

      expect(mockDispatch).not.toHaveBeenCalled();
    });

    it('should dispatch tracking event when eDocsStatus is true', async () => {
      const mockOnboardingData = {
        getOnboardingAndEdocsStatus: {
          showOnboarding: true,
          showEdocs: true,
          onboardingType: 'GOB',
          eDocsStatus: true,
          policies: ['policy1']
        },
      };

      const mocks = [
        {
          request: {
            query: ONBOARDING_QUERY,
            variables: {
              policy_statuses: ['ACTIVE'],
            },
          },
          result: {
            data: mockOnboardingData,
          },
        },
      ];

      let rendered;
      await act(async () => {
        rendered = renderHook(
          () => useGetOnboardingAndEdocsDetails(mockAppState.setAppState),
          { wrapper: createWrapperWithTracking(mocks) }
        );
        await new Promise(resolve => setTimeout(resolve, 0));
      });

      await rendered.waitFor(
        () => {
          expect(mockDispatch).toHaveBeenCalledWith({
            interaction: Interaction.HIDE,
            element: {
              name: 'skip-onboarding',
              value: 'edocs-enabled',
              type: ElementType.MESSAGE,
            },
          });
        },
        { timeout: 2000 }
      );
    });

    it('should not dispatch tracking event when eDocsStatus is false', async () => {
      const mockOnboardingData = {
        getOnboardingAndEdocsStatus: {
          showOnboarding: true,
          showEdocs: false,
          onboardingType: 'GOB',
          eDocsStatus: false,
          policies: ['policy1']
        },
      };

      const mocks = [
        {
          request: {
            query: ONBOARDING_QUERY,
            variables: {
              policy_statuses: ['ACTIVE'],
            },
          },
          result: {
            data: mockOnboardingData,
          },
        },
      ];

      let rendered;
      await act(async () => {
        rendered = renderHook(
          () => useGetOnboardingAndEdocsDetails(mockAppState.setAppState),
          { wrapper: createWrapperWithTracking(mocks) }
        );
        await new Promise(resolve => setTimeout(resolve, 0));
      });

      await rendered.waitFor(
        () => {
          expect(mockDispatch).not.toHaveBeenCalled();
        },
        { timeout: 2000 }
      );
    });

    it('should not dispatch tracking event when data is undefined', async () => {
      const mocks = [
        {
          request: {
            query: ONBOARDING_QUERY,
            variables: {
              policy_statuses: ['ACTIVE'],
            },
          },
          result: {
            data: null,
          },
        },
      ];

      let rendered;
      await act(async () => {
        rendered = renderHook(
          () => useGetOnboardingAndEdocsDetails(mockAppState.setAppState),
          { wrapper: createWrapperWithTracking(mocks) }
        );
        await new Promise(resolve => setTimeout(resolve, 0));
      });

      await rendered.waitFor(
        () => {
          expect(mockDispatch).not.toHaveBeenCalled();
        },
        { timeout: 2000 }
      );
    });
  });
});
