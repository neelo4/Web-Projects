describe('useGetOnboardingAndEdocsDetails', () => {
  const mockDispatch = jest.fn();
  const mockSetAppState = jest.fn();

  const mockAppContextValue = {
    setAppState: mockSetAppState,
    appState: {},
  };

  // Helper function for waiting
  const wait = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

  type WrapperProps = {
    children: React.ReactNode;
    mocks?: any[];
  };

  const createWrapper = (mocks: any[] = []) => {
    const Wrapper: React.FC<WrapperProps> = ({ children }) => (
      <AppContext.Provider value={mockAppContextValue}>
        <SiteTrackingContext.Provider value={{ dispatch: mockDispatch }}>
          <MockedProvider mocks={mocks} addTypename={false}>
            {children}
          </MockedProvider>
        </SiteTrackingContext.Provider>
      </AppContext.Provider>
    );
    return Wrapper;
  };

  beforeEach(() => {
    jest.clearAllMocks();
    (useFeaturesConfig as jest.Mock).mockImplementation(() => true);
    (useBrowserDetect as jest.Mock).mockImplementation(() => ({ isMobileApp: false }));
    (getActivePolicyStatus as jest.Mock).mockReturnValue(['ACTIVE']);
    window.sessionStorage.clear();
  });

  describe('Tracking Events', () => {
    it('should dispatch tracking event when eDocsStatus is true', async () => {
      // Given
      const mockOnboardingData = {
        getOnboardingAndEdocsStatus: {
          showOnboarding: true,
          showEdocs: true,
          onboardingType: 'GOB',
          eDocsStatus: true,
          policies: ['policy1']
        },
      };

      const mocks = [{
        request: {
          query: ONBOARDING_QUERY,
          variables: {
            policy_statuses: ['ACTIVE'],
          },
        },
        result: {
          data: mockOnboardingData,
        },
      }];

      // When
      renderHook(
        () => useGetOnboardingAndEdocsDetails(mockAppState.setAppState),
        { wrapper: createWrapper(mocks) }
      );

      // Then
      // Wait for Apollo mock to resolve and effect to run
      await wait(0);
      
      // Verify the dispatch call
      expect(mockDispatch).toHaveBeenCalledWith({
        interaction: Interaction.HIDE,
        element: {
          name: 'skip-onboarding',
          value: 'edocs-enabled',
          type: ElementType.MESSAGE,
        },
      });
    });

    it('should not dispatch tracking event when eDocsStatus is false', async () => {
      // Given
      const mockOnboardingData = {
        getOnboardingAndEdocsStatus: {
          showOnboarding: true,
          showEdocs: false,
          onboardingType: 'GOB',
          eDocsStatus: false,
          policies: ['policy1']
        },
      };

      const mocks = [{
        request: {
          query: ONBOARDING_QUERY,
          variables: {
            policy_statuses: ['ACTIVE'],
          },
        },
        result: {
          data: mockOnboardingData,
        },
      }];

      // When
      renderHook(
        () => useGetOnboardingAndEdocsDetails(mockAppState.setAppState),
        { wrapper: createWrapper(mocks) }
      );

      // Then
      await wait(0);
      expect(mockDispatch).not.toHaveBeenCalled();
    });

    it('should not dispatch tracking event when data is undefined', async () => {
      // Given
      const mocks = [{
        request: {
          query: ONBOARDING_QUERY,
          variables: {
            policy_statuses: ['ACTIVE'],
          },
        },
        result: {
          data: null,
        },
      }];

      // When
      renderHook(
        () => useGetOnboardingAndEdocsDetails(mockAppState.setAppState),
        { wrapper: createWrapper(mocks) }
      );

      // Then
      await wait(0);
      expect(mockDispatch).not.toHaveBeenCalled();
    });

    it('should skip query when using mobile app', async () => {
      // Given
      (useBrowserDetect as jest.Mock).mockReturnValue({ isMobileApp: true });
      
      // When
      renderHook(
        () => useGetOnboardingAndEdocsDetails(mockAppState.setAppState),
        { wrapper: createWrapper() }
      );

      // Then
      await wait(0);
      expect(mockDispatch).not.toHaveBeenCalled();
    });

    it('should skip query when session storage has onboarding key', async () => {
      // Given
      window.sessionStorage.setItem(ONBOARDING_KEY, 'true');

      // When
      renderHook(
        () => useGetOnboardingAndEdocsDetails(mockAppState.setAppState),
        { wrapper: createWrapper() }
      );

      // Then
      await wait(0);
      expect(mockDispatch).not.toHaveBeenCalled();
    });
  });
});
